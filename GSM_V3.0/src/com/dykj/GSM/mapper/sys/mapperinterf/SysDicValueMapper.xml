<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.dykj.GSM.mapper.sys.mapperinterf.SysDicValueMapper">
   <cache type="org.mybatis.caches.ehcache.LoggingEhcache"/>
   <resultMap type="SysDicValue" id="dicvalueResult">
            <id column="CODE" property="code"/>
       
   
    <result column="CREATE_DATE" property="createDate" jdbcType="VARCHAR" />
    <result column="CREATE_BY" property="createBy" jdbcType="VARCHAR" />
    <result column="FLAG_DEL" property="flagDel" jdbcType="CHAR" />
    <result column="FLAG_DISPLAY" property="flagDisplay" jdbcType="CHAR" />
    <result column="SORT" property="sort" jdbcType="DECIMAL" />
    <result column="REMARK" property="remark" jdbcType="VARCHAR" />
    <result column="NAME_C" property="dicValue" jdbcType="VARCHAR" />
    <result column="SYS_DIC_CODE" property="dicCode" jdbcType="VARCHAR" />
    <result column="PARENT_CODE" property="parentCode" jdbcType="VARCHAR" />
    <result column="TOTAL_NAME" property="totalName" jdbcType="VARCHAR" />
    

   </resultMap>
   <!-- <parameterMap type="map" id="paramMap">
      <parameter property="param" javaType="com.dykj.GSM.model.User" jdbcType="VARCHAR"/>
   </parameterMap> -->
   <!-- 保存实体对象  -->
   <!-- keyProperty	selectKey 语句结果应该被设置的目标属性。  -->
   <!-- resultType	结果的类型。MyBatis 通常可以算出来,但是写上也没有问题。MyBatis 允许任何简单类型用作主键的类型,包括字符串。 -->
   <!-- order	这可以被设置为 BEFORE 或 AFTER。如果设置为 BEFORE,那么它会首先选择主键,设置 keyProperty 然后执行插入语句。
   如果设置为 AFTER,那么先执行插入语句,然后是 selectKey 元素-这和如 Oracle 数据库相似,可以在插入语句中嵌入序列调用。 -->
   <!-- statementType	和前面的相 同,MyBatis 支持 STATEMENT ,PREPARED 和CALLABLE 语句的映射类型,分别代表 PreparedStatement 和CallableStatement 类型。 -->
  <insert id="insert" parameterType="SysDicValue" >
   <selectKey keyProperty="code" resultType="String" order="BEFORE">
        SELECT SYS_GUID() FROM DUAL
      </selectKey>
	insert into SYS_DIC_VALUE (CODE, CREATE_DATE, CREATE_BY,
	FLAG_DEL, FLAG_DISPLAY, 
	SORT, NAME_C,SYS_DIC_CODE,PARENT_CODE, REMARK,TOTAL_NAME)
	values (#{code,jdbcType=VARCHAR}, #{createDate,jdbcType=DATE},
	#{createBy,jdbcType=VARCHAR},
	#{flagDel,jdbcType=VARCHAR}, #{flagDisplay,jdbcType=VARCHAR}, 
	#{sort,jdbcType=DECIMAL}, #{dicValue,jdbcType=VARCHAR}, #{dicCode,jdbcType=VARCHAR}, #{parentCode,jdbcType=VARCHAR},
	#{remark,jdbcType=CLOB},#{totalName})

  </insert>
    
    <!-- 更新实体对象   -->
   <update id="update" parameterType="SysDicValue" >
    <!--
      WARNING - @mbggenerated
      This element is automatically generated by MyBatis Generator, do not modify.
    -->
    update SYS_DIC_VALUE
    <set >
      <if test="createDate != null" >
        CREATE_DATE = #{createDate,jdbcType=VARCHAR},
      </if>
      <if test="createBy != null" >
        CREATE_BY = #{createBy,jdbcType=VARCHAR},
      </if>
      <if test="totalName != null" >
        TOTAL_NAME = #{totalName,jdbcType=CHAR},
      </if>
      
      <if test="sort != null" >
        SORT = #{sort,jdbcType=DECIMAL},
      </if>
      <if test="remark != null" >
        REMARK = #{remark,jdbcType=VARCHAR},
      </if>
      <if test="dicValue != null" >
        NAME_C = #{dicValue,jdbcType=VARCHAR},
      </if>
      <if test="dicCode != null" >
        SYS_DIC_CODE = #{dicCode,jdbcType=VARCHAR},
      </if>
      <if test="parentCode != null" >
        PARENT_CODE = #{parentCode,jdbcType=VARCHAR},
      </if>
      
      
    </set>
    where CODE = #{code,jdbcType=VARCHAR}
  </update>
     <!-- 更新实体对象 (参数)  -->
    <update id="updateByPrimaryKey" parameterType="SysDicValue" >
    update SYS_DIC
    set CREATE_DATE = #{createDate,jdbcType=VARCHAR},
      CREATE_BY = #{createBy,jdbcType=VARCHAR},
      FLAG_DEL = #{flagDel,jdbcType=CHAR},
      FLAG_DISPLAY = #{flagDisplay,jdbcType=CHAR},
      SORT = #{sort,jdbcType=DECIMAL},
      REMARK = #{remark,jdbcType=VARCHAR},
      GPS_NAME = #{gpsName,jdbcType=VARCHAR},
      GPS_IMEI = #{gpsImei,jdbcType=VARCHAR},
      GPS_SIMNO = #{gpsSimno,jdbcType=VARCHAR},
      GPS_USER_CODE = #{gpsUsercode,jdbcType=VARCHAR},
      GPS_POSITION_TIME = #{gpsPositionTime,jdbcType=VARCHAR},
      GPS_POSITION_MSG = #{gpsPositionMsg,jdbcType=VARCHAR},
      GPS_STATE = #{gpsState,jdbcType=CHAR},
      GPS_STATE_STRING = #{gpsStateString,jdbcType=VARCHAR},
      REAL_NAME = #{realName,jdbcType=VARCHAR}
    where CODE = #{code,jdbcType=VARCHAR}
  </update>
    <!-- 根据主键删除实体对象(为假删，规定：0为显示，1为删除) -->
    <update id="deletePk" parameterType="String">
       UPDATE SYS_DIC SET FLAG_DEL=1 WHERE CODE in (select code from sys_dic_value where flag_del=0 start with code=#{code} CONNECT by PRIOR code=parent_code)
    </update>
    
    <!-- 批量删除(为假删，规定：0为显示，1为删除) ，预留接口，但不对其实现功能-->
    <update id="deleteBatch">
       UPDATE SYS_DIC_VALUE SET FLAG_DEL=1 WHERE CODE IN 
       <trim prefix="(" suffix=")" suffixOverrides=",">
          <foreach collection="list" item="code" separator=",">
	          #{code}
          </foreach>
       </trim>
    </update>
    
    <!-- 根据主键查询实体对象  -->
    <select id="queryByKey" parameterType="String" resultMap="dicvalueResult">
        SELECT * FROM SYS_DIC_VALUE WHERE FLAG_DEL != 1 AND CODE=#{code}
    </select>
    
     <!-- 查询所有实体对象集合  -->
   <select id="queryList" resultMap="dicvalueResult">
   		SELECT * FROM SYS_DIC where FLAG_DEL !=1 ORDER BY CODE ASC 
   </select>
    
   <!-- 根据条件查询所有实体对象集合  -->
   <select id="queryListParam" parameterType="SysDicValue" resultMap="dicvalueResult">
   		   SELECT * FROM SYS_DIC_VALUE where FLAG_DEL != 1 and SYS_DIC_CODE=#{dicCode,jdbcType=VARCHAR}
   		   
   </select>
   
   <!-- 对外提供的接口  -->
   <select id="queryManageTree" parameterType="String" resultMap="dicvalueResult">
   		   SELECT SYS_DIC_VALUE.CODE AS CODE,
			SYS_DIC_VALUE.NAME_C,
			SYS_DIC_VALUE.PARENT_CODE 
			FROM SYS_DIC 
			INNER JOIN SYS_DIC_VALUE ON SYS_DIC_VALUE.SYS_DIC_CODE=SYS_DIC.CODE 
			WHERE SYS_DIC_VALUE.FLAG_DEL!=1 AND NAME_DIC=#{code}
   </select>
   
   <!-- 根据条件查询所有实体对象集合  -->
   <select id="queryListParams" parameterType="String" resultMap="dicvalueResult">
   		   SELECT * FROM SYS_DIC_VALUE where FLAG_DEL != 1 and SYS_DIC_CODE=#{code}
   		   
   </select>
    <!-- 根据dicCode检验是否存在同名  -->
   <select id="querySameNameCount" parameterType="java.util.Map" resultType="Integer">
   		   select count(*) from sys_dic_value where flag_del=0 and SYS_DIC_CODE=#{sysDicCode} and NAME_C=#{nameC}
   		   <if test="code != null" >
   		   and CODE!=#{code}
   		   </if>
   </select>
   <!-- 修改下级字典值的所有totalName -->
   <update id="updateAllChildrenTotalName" parameterType="java.util.Map">
   		update SYS_DIC_VALUE set 
   		total_name=substr(replace('-'||total_name||'-','-'||#{beforeName}||'-','-'||#{nowName}||'-'),2,length(replace('-'||total_name||'-','-'||#{beforeName}||'-','-'||#{nowName}||'-'))-2)
    where code in (select code from sys_dic_value where flag_del=0 start with code=#{code} CONNECT by PRIOR code=parent_code)
   </update>
    <!-- 根据字典值主键查询所有实体对象集合  -->
   <select id="queryListByCodes" parameterType="java.util.List" resultType="java.util.Map">
   		SELECT CODE as code, NAME_C as name,SYS_DIC_CODE as dicCode,TOTAL_NAME as totalname FROM SYS_DIC_value where FLAG_DEL !=1 
   		and code in 
   		 <trim prefix="(" suffix=")" suffixOverrides=",">
          <foreach collection="list" item="code" separator=",">
	          #{code}
          </foreach>
       </trim>
   </select>
</mapper>
 